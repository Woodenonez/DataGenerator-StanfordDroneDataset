import os, sys
from pathlib import Path

import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import matplotlib.patches as patches

from util import utils_data

'''
There are 3 kinds of folder structure:
1. [1c] data_dir - obj
2. [2c] data_dir - obj - obj&env (each object has its own environment)
3. [2c] data_dir - obj&env       (all objects share one environment)
(2 & 3 is compatible with 1 to some extent)

Functions 'gen_csv_trackers' and 'gather_all_data' are universal.
They only depend on the data structure version.
'''

def gen_csv_trackers(data_dir): # Data structure 1 or 3
    # data_dir  -  obj & env
    obj_folders = os.listdir(data_dir)
    for objf in obj_folders:
        if objf == 'env':
            continue
        obj_files = os.listdir(os.path.join(data_dir, objf)) # all files/images under this folder
        t_list = []   # time or time step
        x_list = []   # x coordinate
        y_list = []   # y coordinate
        idx_list = [] # more information (e.g. scene index)
        invalid_files = []
        for f in obj_files:
            info = f[:-4] # the last for characters are filename extensions
            try:
                t_list.append(int(info.split('_')[1]))
                x_list.append(float(info.split('_')[2]))
                y_list.append(float(info.split('_')[3]))
                idx_list.append(int(info.split('_')[4]))
            except:
                invalid_files.append(f)
                continue
        for f in invalid_files:
            obj_files.remove(f)
        df = pd.DataFrame({'f':obj_files,'t':t_list,'x':x_list,'y':y_list, 'index':idx_list}).sort_values(by='t', ignore_index=True)
        df.to_csv(os.path.join(data_dir, objf, 'data.csv'), index=False)

def gather_all_data(data_dir, past, maxT, channel_per_image=1, minT=1, period=1, save_dir=None): # Data structure 3
    # data_dir  -  objf(1,2,...) & env
    if save_dir is None:
        save_dir = data_dir
    cpi = channel_per_image

    column_name = [f'f{i}' for i in range(0,cpi*(past+1))] + ['T', 'x', 'y', 'index']
    df_all = pd.DataFrame(columns=column_name)
    obj_folders = os.listdir(data_dir)
    if cpi == 2:
        obj_folders.remove('env')
        # env_folder = os.path.join(data_dir+'env')
    cnt = 0
    for objf in obj_folders:
        cnt += 1
        print(f'\rProcess {cnt}/{len(obj_folders)}', end='    ')
        df_obj = pd.read_csv(os.path.join(data_dir, objf, 'data.csv')) # generated by "gen_csv_trackers"
        for T in range(minT,maxT+1):
            sample_list = []
            for i in range(len(df_obj)-past*period-T): # each sample
                sample = []
                ################## Sample START ##################
                for j in range(past+1):
                    obj_filename = df_obj.iloc[i+j*period]['f']
                    sample.append(obj_filename)
                    if cpi == 2:
                        sample.append(obj_filename.split('_')[1]+'_'+obj_filename.split('_')[-1])
                sample.append(T)
                sample.append(df_obj.iloc[i+past+T]['x'])
                sample.append(df_obj.iloc[i+past+T]['y'])
                sample.append(df_obj.iloc[i+past+T]['index'])
                ################## Sample E N D ##################
                sample_list.append(sample)
            df_T = pd.DataFrame(sample_list, columns=df_all.columns)
            df_all = pd.concat([df_all, df_T], ignore_index=True)
    df_all.to_csv(os.path.join(save_dir, 'all_data.csv'), index=False)


def save_SDD_data_box(video_reader, save_path, channel_per_image=2, period=1, dots_per_inch=96):    # save as bounding boxes
    video_idx = video_reader.video_idx
    cpi = channel_per_image
    dpi = dots_per_inch
    
    if dpi is not None:
        figsize = (video_reader.info('width')/dpi, video_reader.info('height')/dpi)
    else:
        figsize = None

    cnt = 0
    period_cnt = 0
    while(1):
        try:
            frame, df_frame = video_reader.read_frame_clean()
            cnt += 1
            print(f'\rAnalyzing: Frame {cnt}/{video_reader.info("nframes")}', end='   ')
            if period_cnt < period-1:
                period_cnt += 1
                continue
            else:
                period_cnt = 0
            frame = frame[...,::-1] # same as cv2.COLOR_BGR2RGB
        except:
            break
        if df_frame.shape[0] < 1:
            continue

        ### Start to save trajectories
        for j in range(len(df_frame)):
            df_obj = df_frame.iloc[j,:]
            if df_obj['lost'] == 1: # if the object is lost, don't save it
                continue
            x = (df_obj['xmin'] + df_obj['xmax']) / 2
            y = (df_obj['ymin'] + df_obj['ymax']) / 2
            shape = patches.Rectangle((df_obj['xmin'],df_obj['ymin']), 
                                      df_obj['xmax']-df_obj['xmin'], df_obj['ymax']-df_obj['ymin'],
                                      fc='k') # object shape in rectangle

            white_canvas = np.ones_like(frame[:,:,0])
            white_canvas[0,0] = 0
            if cpi == 1:
                _, ax = plt.subplots(figsize=figsize, dpi=dpi)
                ax.matshow(frame)
                ax.add_patch(shape)
                ax.set_aspect('equal', 'box')
                ax.axis('off')
                if save_path is None:
                    plt.show()
                else:
                    folder = os.path.join(save_path,f'{df_obj["ID"]}/')
                    Path(folder).mkdir(parents=True, exist_ok=True)
                    plt.savefig(os.path.join(folder,f'{df_obj["ID"]}_{cnt}_{round(x,4)}_{round(y,4)}_{video_idx}.jpg'),
                                bbox_inches='tight', pad_inches=0, dpi=dpi)
                    plt.close() # "cnt" is the frame counter
            elif cpi == 2:
                _, ax1 = plt.subplots(figsize=figsize, dpi=dpi) # images only containing the target
                white_canvas[df_obj['ymin']:df_obj['ymax'], df_obj['xmin']:df_obj['xmax']] = 0
                ax1.matshow(white_canvas, cmap='gray')
                ax1.set_aspect('equal', 'box')
                ax1.axis('off')
                if save_path is None:
                    plt.show()
                else:
                    folder = os.path.join(save_path,f'{df_obj["ID"]}/')
                    Path(folder).mkdir(parents=True, exist_ok=True)
                    plt.savefig(os.path.join(folder,f'{df_obj["ID"]}_{cnt}_{round(x,4)}_{round(y,4)}_{video_idx}.jpg'),
                                bbox_inches='tight', pad_inches=0, dpi=dpi)
                    plt.close() # "cnt" is the frame counter
            else:
                raise(ModuleNotFoundError('CPI must be 1 or 2.'))
        if cpi == 2:
            _, ax2 = plt.subplots(figsize=figsize, dpi=dpi) # images containing the environment
            ax2.matshow(frame)
            ax2.set_aspect('equal', 'box')
            ax2.axis('off')
            if save_path is None:
                plt.show()
            else:
                folder = os.path.join(save_path,'env/')
                Path(folder).mkdir(parents=True, exist_ok=True)
                plt.savefig(os.path.join(folder,f'{cnt}_{video_idx}.jpg'), 
                            bbox_inches='tight', pad_inches=0, dpi=dpi)
                plt.close() # "cnt" is the frame counter

    video_reader.cap.release()
    print()

def save_SDD_data_gaumap(video_reader, save_path, channel_per_image=2, period=1, dots_per_inch=96): # save as Gaussian map
    video_idx = video_reader.video_idx
    dpi = dots_per_inch
    assert(channel_per_image==2),("Channel per image must be (2).")

    if dpi is not None:
        figsize = (video_reader.info('width')/dpi, video_reader.info('height')/dpi)
    else:
        figsize = None

    cnt = 0
    period_cnt = 0
    while(1):
        try:
            frame, df_frame = video_reader.read_frame_clean()
            cnt += 1
            print(f'\rAnalyzing: Frame {cnt}/{video_reader.info("nframes")}', end='   ')
            if period_cnt < period-1:
                period_cnt += 1
                continue
            else:
                period_cnt = 0
            frame = frame[...,::-1] # same as cv2.COLOR_BGR2RGB
        except:
            break
        if df_frame.shape[0] < 1:
            continue

        ### Start to save trajectories
        for j in range(len(df_frame)):
            df_obj = df_frame.iloc[j,:]
            if df_obj['lost'] == 1: # if the object is lost, don't save it
                continue
            x = (df_obj['xmin'] + df_obj['xmax']) / 2
            y = (df_obj['ymin'] + df_obj['ymax']) / 2

            white_canvas = np.zeros_like(frame[:,:,0])
            input_map = utils_data.np_gaudist_map((x,y), white_canvas, sigmas=[30,30])
            
            _, ax1 = plt.subplots(figsize=figsize, dpi=dpi) # images only containing the target
            ax1.matshow(input_map, cmap='gray')
            ax1.set_aspect('equal', 'box')
            ax1.axis('off')
            if save_path is None:
                plt.show()
            else:
                folder = os.path.join(save_path,f'{df_obj["ID"]}/')
                Path(folder).mkdir(parents=True, exist_ok=True)
                plt.savefig(os.path.join(folder,f'{df_obj["ID"]}_{cnt}_{round(x,4)}_{round(y,4)}_{video_idx}.jpg'),
                            bbox_inches='tight', pad_inches=0, dpi=dpi)
                plt.close() # "cnt" is the frame counter

            _, ax2 = plt.subplots(figsize=figsize, dpi=dpi) # images containing the environment
            ax2.matshow(frame)
            ax2.set_aspect('equal', 'box')
            ax2.axis('off')
            if save_path is None:
                plt.show()
            else:
                folder = os.path.join(save_path,'env/')
                Path(folder).mkdir(parents=True, exist_ok=True)
                plt.savefig(os.path.join(folder,f'{cnt}_{video_idx}.jpg'), 
                            bbox_inches='tight', pad_inches=0, dpi=dpi)
                plt.close() # "cnt" is the frame counter

    video_reader.cap.release()
    print()

def save_SDD_data_eucl(video_reader, save_path, channel_per_image=2, period=1, dots_per_inch=96): # save as Euclidean distance map
    video_idx = video_reader.video_idx
    dpi = dots_per_inch
    assert(channel_per_image==2),("Channel per image must be (2).")

    if dpi is not None:
        figsize = (video_reader.info('width')/dpi, video_reader.info('height')/dpi)
    else:
        figsize = None

    cnt = 0
    period_cnt = 0
    while(1):
        try:
            frame, df_frame = video_reader.read_frame_clean()
            cnt += 1
            print(f'\rAnalyzing: Frame {cnt}/{video_reader.info("nframes")}', end='   ')
            if period_cnt < period-1:
                period_cnt += 1
                continue
            else:
                period_cnt = 0
            frame = frame[...,::-1] # same as cv2.COLOR_BGR2RGB
        except:
            break
        if df_frame.shape[0] < 1:
            continue

        ### Start to save trajectories
        for j in range(len(df_frame)):
            df_obj = df_frame.iloc[j,:]
            if df_obj['lost'] == 1: # if the object is lost, don't save it
                continue
            x = (df_obj['xmin'] + df_obj['xmax']) / 2
            y = (df_obj['ymin'] + df_obj['ymax']) / 2

            white_canvas = np.zeros_like(frame[:,:,0])
            input_map = utils_data.np_dist_map((x,y), white_canvas)
            
            _, ax1 = plt.subplots(figsize=figsize, dpi=dpi) # images only containing the target
            ax1.matshow(input_map, cmap='gray')
            ax1.set_aspect('equal', 'box')
            ax1.axis('off')
            if save_path is None:
                plt.show()
            else:
                folder = os.path.join(save_path,f'{df_obj["ID"]}/')
                Path(folder).mkdir(parents=True, exist_ok=True)
                plt.savefig(os.path.join(folder,f'{df_obj["ID"]}_{cnt}_{round(x,4)}_{round(y,4)}_{video_idx}.jpg'),
                            bbox_inches='tight', pad_inches=0, dpi=dpi)
                plt.close() # "cnt" is the frame counter

            _, ax2 = plt.subplots(figsize=figsize, dpi=dpi) # images containing the environment
            ax2.matshow(frame)
            ax2.set_aspect('equal', 'box')
            ax2.axis('off')
            if save_path is None:
                plt.show()
            else:
                folder = os.path.join(save_path,'env/')
                Path(folder).mkdir(parents=True, exist_ok=True)
                plt.savefig(os.path.join(folder,f'{cnt}_{video_idx}.jpg'), 
                            bbox_inches='tight', pad_inches=0, dpi=dpi)
                plt.close() # "cnt" is the frame counter

    video_reader.cap.release()
    print()
